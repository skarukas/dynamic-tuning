!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e=e||self).tune=t()}(this,function(){"use strict";const e={round:(e,t=0)=>{let r=Math.pow(10,t);return Math.round(e*r)/r},log:(e,t)=>Math.log(e)/Math.log(t),log2:t=>e.log(t,2),mod:(e,t)=>(e%t+t)%t,divide:(t,r)=>[Math.floor(t/r),e.mod(t,r)],powerMod:(t,r)=>Math.pow(r,e.mod(e.log(t,r),1)),absCeil:e=>e>=0?Math.ceil(e):Math.floor(e),refA:440,ETToFreq:(t,r=12)=>e.refA*Math.pow(2,t/r-5.75),freqToET:(t,r=12)=>r*(e.log2(t/e.refA)+5.75),pitchToChromaticNoteName:t=>{return["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"][Math.round(e.mod(t,12))]},dtf(e,t=9){let r,n,s=Math.pow(10,-t),i=e,o=Math.floor(i),a=1,h=0,c=o,l=1;for(;i-o>s*l*l;)i=1/(i-o),c=(r=a)+(o=Math.floor(i))*(a=c),l=(n=h)+o*(h=l);return[c,l]},__primes__:[],primesUpTo(t){if(t<2)return[];let r=e.__primes__,n=r.length-1;if(n>=0&&t<=r[n]){for(;t<r[n];)n--;return r.slice(0,n+1)}n=-1==n?2:r[n]+1;e:for(;n<=t;n++){for(let e of r){if(e>Math.sqrt(n))break;if(n%e==0)continue e}r.push(n)}return r.slice()},largestPrimeFactor(t){if(t%1!=0)return 1;let r=e.primesUpTo(t);for(let e=r.length-1;e>=0;e--)if(t%r[e]==0)return r[e];return 1},getPairs(e){let t=[];for(let r=0;r<e.length;r++)for(let n=r+1;n<e.length;n++)t.push([e[r],e[n]]);return t},getMin(e,t){t=((e,t)=>e<t);let r=0,n=e[0];for(let s=0;s<e.length;s++)t(e[s],n)&&(r=s,n=e[s]);return{index:r,value:n}},isValidIndex:(t,r)=>t>=0&&0==e.mod(t,1)&&t<r};class t{constructor(){this.__name__=""}equals(e){return this.cents()==e.cents()}toString(){return this.name}}class r extends t{constructor(){super(...arguments),this.isStructural=!1}static inFreqRange(e,t){return function(r){let n=r.getFrequency();return n>=e&&n<=t}}static inPitchRange(e,t){return function(r){let n=r.getETPitch();return n>=e&&n<=t}}getAllNotes(){return[this]}dividedNotesAbove(e,t){let r=Math.ceil(t)-1,n=e.divide(t),s=[],i=this;for(let e=0;e<r;e++)i=i.noteAbove(n),s.push(i);return s.push(this.noteAbove(e)),s}dividedNotesBelow(e,t){return this.dividedNotesAbove(e.inverse(),t)}noteBelow(e){return this.noteAbove(e.inverse())}intervalTo(e){return new f(e.getFrequency(),this.getFrequency())}getRoot(){return this}asFrequency(){return new s(this.getFrequency())}asET(e){return new i(this.getETPitch(e),e)}errorInET(e=12,t=new o(0)){return t.intervalTo(this).errorInET(e)}cents(){return i.middleC.intervalTo(this).normalized().cents()}connect(e,t){return new h(this).connect(e,t)}}class n extends r{get name(){return this.__name__}set name(e){this.__name__=e}transposeBy(e){}noteAbove(e){return new n}getETPitch(e){return NaN}getFrequency(){return NaN}intervalTo(e){return null}asFrequency(){return null}asET(){return null}errorInET(e=12,t){return NaN}cents(){return NaN}}class s extends r{constructor(e){if(super(),this.freq=e,!(e>0))throw new RangeError("Frequencies must be greater than zero.")}get name(){return this.__name__||this.freq.toFixed()+" Hz"}set name(e){this.__name__=e}noteAbove(e){let t=new s(this.freq);return t.transposeBy(e),t}transposeBy(e){this.freq*=e.asFrequency().decimal()}getETPitch(t=12){return e.freqToET(this.freq,t)}getFrequency(){return this.freq}}class i extends r{constructor(e,t=12){if(super(),this.pitch=e,this.base=t,isNaN(e/t))throw new RangeError("ET pitch indices must be numeric.");if(0==t)throw new RangeError("Cannot create an equal division of base zero.")}get name(){return this.__name__||e.pitchToChromaticNoteName(this.getETPitch())}set name(e){this.__name__=e}noteAbove(e){let t=this.pitch+e.asET(this.base).steps;return new this.constructor(t,this.base)}transposeBy(e){this.pitch+=e.asET(this.base).steps}getETPitch(e=12){return this.pitch*e/this.base}getFrequency(){return e.ETToFreq(this.pitch,this.base)}intervalTo(e){return new d(e.getETPitch(this.base)-this.pitch,this.base)}}r.middleC=new i(60);class o extends i{constructor(e,t=60){super(e),this.pitch=e,this.velocity=t}}class a{constructor(e){this.root=e}getRoot(){return this.root}getAllNotes(){return this.notes}getNoteByName(e){for(let t of this.notes)if(t.name==e)return t}transposeBy(e){for(let t of this.notes)t.transposeBy(e)}filter(e){return this.notes.filter(e)}}class h extends a{setInterval(e,t,r){let n=r.subtract(e.intervalTo(t)),s=this.getSubTree(t,e);for(let e of s)e.transposeBy(n)}getNeighbors(e){return this.edges.get(e).keys()}getSubTree(e=this.getRoot(),t){let r=[e];for(let n of this.getNeighbors(e))n!=t&&(r=r.concat(this.getSubTree(n,e)));return r}connect(e,t){let r=this.getRoot(),n=e.getRoot();if(t=t||r.intervalTo(n),this.notes=this.notes.concat(e.getAllNotes()),e instanceof h)for(let[t,r]of e.edges)this.edges.set(t,r);else this.edges.set(n,new Map);this.edges.get(r).set(n,t),this.edges.get(n).set(r,t.inverse());let s=t.subtract(r.intervalTo(n));return e.transposeBy(s),this}add(){}remove(e){let t=this.edges.delete(e);if(t)for(let t of this.edges.values())t.delete(e);return t}}class c{constructor(e,t=1){this.n=e,this.d=t}toString(){return`${this.n}/${this.d}`}static dtf(t){let[r,n]=e.dtf(t);return new c(r,n)}simplified(){return null}decimal(){return this.n/this.d}plus(e){return c.dtf(this.decimal()+e.decimal())}minus(e){return c.dtf(this.decimal()-e.decimal())}times(e){return c.dtf(this.decimal()*e.decimal())}divide(e){return c.dtf(this.decimal()/e.decimal())}}class l extends t{static compareSize(e,t){let r=e.asET(),n=t.asET();return r.n-n.n}static compareComplexity(e,t){let r=e.asFrequency(),n=t.asFrequency(),s=r.largestPrimeFactor(),i=n.largestPrimeFactor();return s!=i?s-i:r.n+r.d-(n.n+n.d)}normalized(){return this.mod(l.octave)}inverse(){return this.multiply(-1)}subtract(e){return this.add(e.inverse())}divide(e){return this.multiply(1/e)}cents(){return e.round(100*this.asET().steps,2)}getNearestET(e=12){let t=this.asET(e);return t.n=Math.round(t.n),t}errorInET(e=12){let t=this.getNearestET(e);return this.subtract(t).cents()}}class u extends l{constructor(e,t=1){super(),this.frac=new c(e,t)}get n(){return this.frac.n}get d(){return this.frac.d}set n(e){this.frac.n=e}set d(e){this.frac.d=e}}class d extends u{constructor(e,t=12){if(super(e,t),this.steps=e,this.base=t,isNaN(e/t))throw new RangeError("ET pitch indices must be numeric.");if(0==t)throw new RangeError("Cannot create an equal division of base zero.")}get name(){return this.__name__||`${this.n} [${this.d}ET]`}set name(e){this.__name__=e}toString(){return this.name}mod(t){let r=t.asET(this.base),n=e.mod(this.n,r.n);return new d(n,this.d)}multiply(e){if(isNaN(e))throw new RangeError("Factors must be numeric.");return new d(this.n*e,this.d)}asFrequency(){let t=Math.pow(2,this.steps/this.base),[r,n]=e.dtf(t);return new f(r,n)}asET(e=12){return e==this.base?this:new d(this.frac.decimal()*e,e)}inverse(){return new d(-this.n,this.d)}add(e){let t=e.asET(this.base);return new d(this.n+t.n,this.base)}}class f extends u{constructor(t,r=1){if(!(t>0&&r>0))throw new RangeError("Frequency ratios must be positive.");(t%1||r%1)&&([t,r]=e.dtf(t/r)),super(t,r)}get name(){return this.__name__||this.n+":"+this.d}set name(e){this.__name__=e}static fromFraction(e){return new f(e.n,e.d)}largestPrimeFactor(){let t=this.normalized();return e.largestPrimeFactor(t.n*t.d)}decimal(){return this.frac.decimal()}valueOf(){return`${this.n}:${this.d}`}mod(t){let r=t.asFrequency().decimal(),n=e.powerMod(this.decimal(),r);return new f(n)}multiply(e){if(isNaN(e))throw new RangeError("Factors must be numeric.");return new f(Math.pow(this.n,e),Math.pow(this.d,e))}asFrequency(){return this}asET(t=12){let r=t*e.log2(this.decimal());return new d(r,t)}inverse(){return new f(this.d,this.n)}add(e){let t=e.asFrequency(),r=this.frac.times(t.frac);return f.fromFraction(r)}}l.octave=new f(2);class g{constructor(){this.edges=new Map}}class m extends g{constructor(e=new n){super(),this.root=e,this.edges.set(e,new Map)}static ET(e,t=new n){let r=t instanceof n?new m(t):new p(t),s=t;for(let t=0;t<e-1;t++)s=r.connectAbove(s,new d(1,e));return r}static harmonicSeries(e,t=new n){let r=t instanceof n?new m(t):new p(t);t.isStructural=!0,"number"==typeof e&&(e=Array.from(Array(e),(e,t)=>t+1));for(let n of e)1==n&&(t.isStructural=!1),r.connectAbove(r.root,new f(n));return r}getAllNotes(){return Array.from(this.edges.keys())}addEdge(e,t,r){this.edges.get(e).set(r,t),this.edges.set(r,new Map),this.edges.get(r).set(e,t.inverse())}contains(e){if(-1!=this.getAllNotes().indexOf(e))return!0;for(let t of this.getAllNotes())if(t.equals(e))return!0;return!1}connectAbove(e,t){if(this.contains(e)){let r=e.noteAbove(t);return this.addEdge(e,t,r),r}throw new Error("Cannot connect from a note not in tree.")}connectBelow(e,t){return this.connectAbove(e,t.inverse())}inverse(){let e=new m(this.root);for(let t of this.edges.keys()){e.edges.set(t,new Map);let r=this.edges.get(t),n=e.edges.get(t);for(let e of r.keys())n.set(e,r.get(e).inverse())}return e}getNeighbors(e){return this.edges.get(e).keys()}getInterval(e,t){return this.edges.get(e).get(t)}withRoot(e){let t=new p(e),r=[this.root],n=[e],s=new Map;for(let e of this.getAllNotes())s.set(e,!1);for(;r.length;){let e=r.pop(),i=n.pop();s.set(e,!0);for(let o of this.getNeighbors(e))if(!s.get(o)){let s=this.getInterval(e,o),a=t.connectAbove(i,s);r.unshift(o),n.unshift(a)}}return t}}class p extends m{inverse(){return super.inverse().withRoot(this.root)}constructor(e){super(e)}}const w={bestFitET(e,t=53){e instanceof Array||(e=[e]);let r=0,n=1/0;for(let s=1;s<=t;s++){let t=w.errorInET(e,s);t<n&&(r=s,n=t)}return r},bestFitETs(e,t=53,r=10){e instanceof Array||(e=[e]),r<1&&(r=t);let n=[];for(let r=1;r<=t;r++){let t=w.errorInET(e,r);n.push([r,t])}return n.sort((e,t)=>e[1]===t[1]?e[0]-t[0]:e[1]-t[1]).map(e=>e[0]).slice(0,r)},errorInET(e,t=12,r="rms"){e instanceof Array||(e=[e]);let n=0;if("rms"==(r=r.toLowerCase())){for(let r of e)n+=Math.pow(r.errorInET(t),2);n=Math.sqrt(n)}else if("abs"==r)for(let r of e)n+=Math.abs(r.errorInET(t));return n/e.length},stepSizeForET:e=>new d(1,e).cents()},v={third:new f(5,4),fifth:new f(3,2),seventh:new f(7,4),eleventh:new f(11,8)},b={bestFitPartials(e,t=.5){let r=e.map(e=>e.getFrequency());return b.bestFitPartialsFromFreq(r,t)},bestFitPartialsFromFreq(t,r=.5){let n=e.getMin(t).value,i=t.map(e=>e/n),o=Array(t.length),a=1;for(;;a++){let n;for(n=0;n<t.length;n++){let t=i[n]*a,s=t/Math.round(t),h=12*e.log2(s);if(!(Math.abs(h)<r))break;o[n]=Math.round(t)}if(n==t.length)break}let h=n/a;return{partials:o,fundamental:h,asTree:()=>m.harmonicSeries(o,new s(h))}}};{let e,t,r,n,s=new m;e=s.root,t=s.connectAbove(e,v.fifth),r=s.connectAbove(t,v.fifth),n=s.connectBelow(e,v.fifth),s.connectAbove(n,v.third),s.connectAbove(e,v.third),s.connectAbove(t,v.third),s.connectAbove(r,v.third),s.connectBelow(n,v.third),s.connectBelow(e,v.third),s.connectBelow(t,v.third),s.connectBelow(r,v.third),m.chromaticFiveLimit=s;let i=new m;e=i.root,t=i.connectAbove(e,v.fifth),r=i.connectAbove(t,v.fifth),n=i.connectBelow(e,v.fifth),i.connectAbove(n,v.third),i.connectAbove(e,v.third),i.connectAbove(t,v.third),m.diatonicFiveLimit=i}function T(e){return new Proxy(e,{apply:(e,t,r)=>new e(...r)})}return{ETPitch:T(i),MIDINote:T(o),Frequency:T(s),NullNote:T(n),IntervalTree:T(m),Note:T(r),Scale:T(class{constructor(e=12,t=l.octave,n=r.middleC.asET(e)){if(this.root=60,this.fixedInput=60,!Number.isInteger(e))throw new Error("Number of notes per octave must be an integer.");this.octaveSize=t,this.notesPerOctave=e,this.map=new Array(e),this.equallyDivide(),this.setRoot(60),this.setFixedMapping(60,n)}get(t){if(!Number.isInteger(t))throw new Error("Scale inputs must be integers.");let r=t-this.root,[n,s]=e.divide(r,this.notesPerOctave),i=this.getIntervalByScaleIndex(s),o=this.getRootNote(),a=i.add(this.octaveSize.multiply(n));return o.noteAbove(a)}set(t,n){if(!Number.isInteger(t))throw new Error("Scale inputs must be integers.");let s=e.mod(t-this.root,this.notesPerOctave),i=n instanceof r?this.getRootNote().intervalTo(n):n;if(0==s)throw new Error("Can't change the root of a mapping");return this.map[s]=i.mod(this.octaveSize),this}setByIndex(t,r){if(!e.isValidIndex(t,this.notesPerOctave))throw new RangeError("Scale indices must be integers in the range [0, notesPerOctave).");return this.map[t]=r.mod(this.octaveSize),this}setFixedMapping(t,r){let[n,s]=e.divide(t,this.notesPerOctave);return this.fixedInput=s,this.fixedOutput=r.noteBelow(this.octaveSize.multiply(n)),this}setRoot(t){if(!Number.isInteger(t))throw new RangeError("Input values must be integers.");return this.root=e.mod(t,this.notesPerOctave),this}equallyDivide(){let e=this.notesPerOctave,t=this.octaveSize.equals(l.octave)?new d(1,e):this.octaveSize.divide(e).asET(e);for(let r=0;r<e;r++)this.map[r]=t.multiply(r)}getIntervalByScaleIndex(t){if(e.isValidIndex(t,this.notesPerOctave))return this.map[t];throw new RangeError("Index out of range. This should not happen unless notesPerOctave was modified.")}getRootNote(){let t=this.fixedInput-this.root,[r,n]=e.divide(t,this.notesPerOctave),s=this.getIntervalByScaleIndex(n);return this.fixedOutput.noteBelow(s.add(this.octaveSize.multiply(r)))}toString(){return this.map.toString()}}),ETInterval:T(d),FreqRatio:T(f),JI:v,Util:e,ET:w,AdaptiveTuning:b}});